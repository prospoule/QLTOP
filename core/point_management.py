# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QLtop
                                 A QGIS plugin
 Outil interactif de préanalyse pour le logiciel LTOP
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-09-25
        git sha              : $Format:%H$
        copyright            : (C) 2020 by HEIG-VD | Nicolas Szakacs
        email                : nicolas.szakacs@heig-vd.ch
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; Version 3 of the License.               *
 *                                                                         *
 ***************************************************************************/
"""

import os
# filesystem paths normalization
from pathlib import Path

# Usefull to translate encoding from Ainsi tu UTF-8
import codecs

# Used to communicate with the user through pushmessages
from qgis.utils import iface
from qgis.core import Qgis
from qgis.core import QgsVectorLayer, QgsField, QgsFeature, QgsGeometry, QgsPointXY, QgsProject

# Used to create a Qgis temporary layer
from qgis.PyQt.QtCore import QVariant, Qt
from qgis.PyQt import QtSql
from qgis.PyQt.QtWidgets import QApplication

from qltop.core.general_tools import *


class loadPoint:
    """
    Purpose :
         - Get a list of point from an Ltop.koo
    Input :
        - Ltop.koo/.coo file
    Output :
        - List of points ready to import in the database
    """

    def __init__(self, koo_path):
        self.koo_path = koo_path            ## Value from btnSelFileKoo button
        self.koo_format = ["$$PK"]          ## Implemented Ltop.koo format so far
        self.file_content = self.read_koo_file(self.koo_path)
        self.file_list = self.split_koo_attributes(self.file_content)

    def read_koo_file(self, filename):
        """ Read the Ltop.koo file and create a list of the content """
        try:
            with codecs.open(filename, "r", encoding="mbcs") as file:    ## mbcs = 'codecs' module 'ainsi' encoding equivalent
                lines = file.read().splitlines()                         ## read each lines
                lines = filter(lambda x: x.strip(), lines)               ## remove empty lines
                lines = filter(lambda x: not x.startswith(";"), lines)   ## remove commentary lines ";"
            return self.check_koo_type(list(lines))
        except:
            print("Point -> Failed to read the Ltop.koo file (def read_koo_file)")

    def check_koo_type(self, koo_lines):
        """
            Check if the input Ltop.koo file is a $$PK
            Only $$PK is implemented in this plugin version
        """
        first_line = koo_lines[0]          ## First line of the Ltop.koo file
        file_koo_format = first_line[0:4]  ## Extract the $$ value
        if file_koo_format in self.koo_format:
            return koo_lines
        else:
            iface.messageBar().pushMessage("Attention : ",
                                           u"*** Seul le format $$PK est supporté ***",
                                           level=Qgis.Warning,
                                           duration=3)

    @staticmethod
    def split_koo_attributes(data):
        """ Extract the attributes of each point to a list """
        column_separator = [10, 4, 8, 4, 6, 12, 12, 4, 10, 4, 2,
                            8, 4, 2,
                            6, 6, 4, 6, 6, 4, 4, 3, 2, 4, 3, 22]  ## Sum = 160
        title_list = []  ## $$ header + title
        point_list = []  ## Point with all the attributes
        total_list = []  ## title list + point list
        if data:
            first_line = data[0]                       ## First line of the Ltop.koo file
            title_list.append(first_line[0:4])         ## $$PK
            title_list.append(first_line[4:].strip())  ## Commentary
            total_list.append(title_list)
            for line in data[1:]:                      ## [1:] = everything except the $$ header
                # attr_list = loadPoint.splitter_koo_pe_pk(line)
                attr_list = gt_splitter_ltop_format(line, column_separator)
                point_list.append(attr_list)
            total_list.append(point_list)
            return total_list


class displayLayerPoint:
    """
        Display the point content of the database in the Qgis canvas
        Input : database name, table to query
        Output : Qgis layer
    """

    # Class variables
    layer_name = "qltop_point"
    qml_style_point = "style_qltop_point.qml"

    def __init__(self, list_points, selected_epsg, zoom):
        self.list_points = list_points
        self.selected_epsg = selected_epsg
        self.zoom = zoom
        self.create_point_layer()

    def create_point_layer(self):
        """ Create an temporary point layer in the Qgis canvas """
        try:
            QApplication.setOverrideCursor(Qt.WaitCursor)  ## Start the 'wait' cursor
            if self.list_points:

                # create layer
                vl = QgsVectorLayer("Point?crs=" + self.selected_epsg, self.layer_name, "memory")
                pr = vl.dataProvider()

                # add fields
                pr.addAttributes([QgsField("id_point", QVariant.Int),
                                  QgsField("nom",  QVariant.String),
                                  QgsField("pfp",  QVariant.Int),
                                  QgsField("pfa", QVariant.Int),
                                  QgsField("ty",  QVariant.String),
                                  QgsField("date_rep",  QVariant.String),
                                  QgsField("ordre",  QVariant.String),
                                  QgsField("num_carte",  QVariant.String),
                                  QgsField("coordY",  QVariant.Double, "double", 12, 4),
                                  QgsField("coordX",  QVariant.Double, "double", 12, 4),
                                  QgsField("coord_prov",  QVariant.String),
                                  QgsField("altitudeH",  QVariant.Double, "double", 10, 4),
                                  QgsField("altitude_prov",  QVariant.String),
                                  QgsField("coord_code",  QVariant.String),
                                  QgsField("geoide_cote",  QVariant.String),
                                  QgsField("geoide_prov",  QVariant.String),
                                  QgsField("ellips_code",  QVariant.String),
                                  QgsField("dev_vert_ETA",  QVariant.String),
                                  QgsField("dev_vert_XI",  QVariant.String),
                                  QgsField("dev_vert_prov",  QVariant.String),
                                  QgsField("dev_vert_ETA0",  QVariant.String),
                                  QgsField("dev_vert_XI0",  QVariant.String),
                                  QgsField("dev_vert_prov0",  QVariant.String),
                                  QgsField("code_raumtri",  QVariant.String),
                                  QgsField("num_cont",  QVariant.String),
                                  QgsField("flag_gps",  QVariant.String),
                                  QgsField("num_sess_gps",  QVariant.String),
                                  QgsField("num_zone",  QVariant.String),
                                  QgsField("reserve",  QVariant.String)])

                vl.updateFields()  # tell the vector layer to fetch changes from the provider

                # add features
                for item in self.list_points:
                    pos_y = float(item[8])
                    pos_x = float(item[9])

                    fet = QgsFeature()
                    fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(pos_y,pos_x)))
                    fet.setAttributes(list(item))
                    pr.addFeatures([fet])

                # add preconfigured qgis.qml style file
                plugin_folder = os.path.dirname(os.path.dirname(__file__))
                qml_file = Path(plugin_folder) / "qml" / self.qml_style_point
                if qml_file.is_file():  # Test if file exist, avoid error if he is missing
                    vl.loadNamedStyle(str(qml_file))

                # update layer's extent when new features have been added
                vl.updateExtents()

                # zoom to the layer extent
                if self.zoom:
                    canvas = iface.mapCanvas()
                    canvas.setExtent(vl.extent())

                # Show in project
                self.rmv_old_qgs_point_layer()
                QgsProject.instance().addMapLayer(vl)
        except:
            QApplication.restoreOverrideCursor()  ## Stop the 'wait' cursor
            print("Point -> Failed to create a new Qgis point layer (def create_point_layer)")
        finally:
            QApplication.restoreOverrideCursor()  ## Stop the 'wait' cursor

    @classmethod
    def rmv_old_qgs_point_layer(cls):
        """ Remove preexisting point layer """
        try:
            names = [layer.name() for layer in QgsProject.instance().mapLayers().values()]
            qgs_instance = QgsProject.instance()
            for name in names:
                if name == cls.layer_name:
                    qgs_instance.removeMapLayer(qgs_instance.mapLayersByName(name)[0].id())
        except:
            print("Point -> Failed to remove the preexisting Qgis point layer (def rmv_old_qgs_point_layer)")


class importQgsPoint:
    """
        Add new point to the database.qltop_points based on the
        geometry of selected item in the Qgis canvas.

        Notes :
        Only the pos_x et pos_y are taken.
        The user must manually add the others attributes.
    """

    def __init__(self):
        self.active_layer = iface.activeLayer()
        self.list_point_2_import = self.select_feat(self.active_layer)

    def select_feat(self, layer):
        """ Retrieve the coordinates of the Qgis selected points """
        try:
            point_list = []
            for elem in layer.selectedFeatures():
                if elem.geometry().wkbType() == 1:     ## Point geometry (1)
                    point = elem.geometry().asPoint()
                else:                                  ## Multipoint geometry (4)
                    point = elem.geometry().asMultiPoint()[0]
                current_point = []
                current_point.append(self.round_point(point.x()))
                current_point.append(self.round_point(point.y()))
                point_list.append(current_point)
            return point_list
        except:
            print("Point -> Failed to retrive the coordinates of the selected qgis points (def select_feat)")

    @staticmethod
    def round_point(val):
        """
        Round the coordinates to 4 decimal
        Also convert to string
        """
        transfo_val = format(round(val, 4), ".4f")
        return transfo_val


class kooPointModel(QtSql.QSqlTableModel):
    """
        .KOO Tab -> 'point_pk' table
        Subclass of model, used to modify the column formatting
    """

    def __init__(self, parent=None):
        QtSql.QSqlTableModel.__init__(self, parent=parent)
        self.setTable("point_pk")
        self.setEditStrategy(QtSql.QSqlTableModel.OnFieldChange)
        self.select()

    def data(self, index, role=Qt.DisplayRole):
        """ Define the role applied to each column """
        val = QtSql.QSqlTableModel.data(self, index, role)
        if role == Qt.TextAlignmentRole:
            if index.column() == 8 or index.column() == 9 or index.column() \
                    == 11 or index.column() == 14:
                return Qt.AlignRight | Qt.AlignVCenter
            else:
                return Qt.AlignLeft | Qt.AlignVCenter  ## Default alignment
        if role == Qt.DisplayRole:  ## Y, X, Z
            if index.column() == 8 or index.column() == 9 \
                    or index.column() == 11:
                try:
                    if gt_isfloat(val):
                        return "{:.4f}".format(round(float(val), 4))
                except ValueError:
                    pass
        return val


class kooUpdateFile():
    """
    Update the Ltop.koo selected file with the database content
    """

    def __init__(self, table_points, selected_koo_file):
        self.table_points = table_points
        self.koo_file = selected_koo_file
        self.clean_list = self.round_double_attributes()
        self.final_list = self.unsplit_attributes()
        self.write_koo_file(self.koo_file, self.final_list)

    def round_double_attributes(self):
        """
        Remove the unwanted attributes (id , pfp and pfa), then
        round the 'double' attributes and convert to string
        """
        rmv_attr = [0, 2, 3]        ## remove id, pfp, pfa
        round_1 = [14, 15, 17, 18]  ## dev_vert_ETA, dev_vert_XI, dev_vert_ETA0, dev_vert_XI0
        round_4 = [5, 6, 8, 11]     ## coordY, coordX, altitudeH, geoide_cote
        clean_list = []  ## Return list
        try:
            # Remove unwanted attributes
            for point in self.table_points:
                point = [i for j, i in enumerate(point) if j not in rmv_attr]
                # Convert float to to string vith rounded decimal
                for idx in enumerate(point):
                    if idx[1] is None:
                        point[idx[0]] = ""
                    if idx[0] in round_1 and idx[1]:
                        point[idx[0]] = "{:.1f}".format(float(idx[1]))
                    if idx[0] in round_4 and idx[1]:
                        point[idx[0]] = "{:.4f}".format(float(idx[1]))
                clean_list.append(point)
            return clean_list
        except:
            print("Point -> Failed to round the double attributes (def round_double_attributes)")

    def unsplit_attributes(self):
        """ Concatenate the attributes in a single line as described in the Ltop.koo schema model """
        column_separator = [10, 4, 8, 4, 6, 12, 12, 4, 10, 4, 2, 8, 4, 2, 6, 6, 4, 6, 6, 4, 4, 3, 2, 4, 3, 22]  ## length of each attributes
        right_alignment = [5, 6, 8, 11, 14, 15, 17, 18]  ## This idx must have a right alignment (float) | other left (string)
        final_list = []  ## Return list
        try:
            for point in self.clean_list:
                for idx in enumerate(point):
                    max_length = column_separator[idx[0]]
                    actual_length = len(idx[1])
                    if actual_length > max_length:
                        point[idx[0]] = idx[1][-max_length:]
                    if actual_length < max_length:
                        if idx[0] in right_alignment:  ## float value only
                            point[idx[0]] = " "*(max_length-actual_length) + idx[1]
                        else:  ## string value only
                            point[idx[0]] = idx[1] + " "*(max_length-actual_length)
                tmp_list = "".join(map(str, point))
                final_list.append(tmp_list)
            return final_list
        except:
            print("Point -> Failed to transform the points data to Ltop rows (def unsplit_attributes)")

    @staticmethod
    def write_koo_file(filename, point_data):
        """
        Read the Ltop.koo file and retrieve the first line
        then replace the point content
        """
        try:
            with codecs.open(filename, "r+", encoding="mbcs") as file:    ## mbcs = 'codecs' module 'ainsi' encoding equivalent
                items = list(map(lambda x: x + "\r\n", point_data))  ## Add break line at the end of each line
                first_line = file.readline()
                if first_line[:2] == "$$":
                    items.insert(0, first_line)
                file.seek(0)
                file.writelines(items)
                file.truncate()
            iface.messageBar().pushMessage("Info : ",
                                           u"*** Mise jour du fichier '{}' effectué avec succès ***".format(filename),
                                           level=Qgis.Success,
                                           duration=2)
        except:
            iface.messageBar().pushMessage("Attention : ",
                                           u"*** La mise jour du fichier '{}' a échoué ***".format(filename),
                                           level=Qgis.Warning,
                                           duration=3)
            print("Point -> Failed to write the points to the selected Ltop.koo file (def write_koo_file)")
