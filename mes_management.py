# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QLtop
                                 A QGIS plugin
 Outil interactif de préanalyse pour le logiciel LTOP
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-09-25
        git sha              : $Format:%H$
        copyright            : (C) 2020 by HEIG-VD | Nicolas Szakacs
        email                : nicolas.szakacs@heig-vd.ch
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; Version 3 of the License.               *
 *                                                                         *
 ***************************************************************************/
"""

import os

# Usefull to translate encoding from Ainsi tu UTF-8
import codecs

from pathlib import Path
from itertools import groupby

from qgis.PyQt import QtSql
from qgis.PyQt.QtCore import Qt

# Used to create a Qgis temporary layer
from qgis.utils import iface
from qgis.PyQt.QtCore import QVariant
from qgis.core import QgsVectorLayer, QgsField, QgsFeature, QgsGeometry, QgsPoint, \
                      QgsProject, QgsExpression, QgsExpressionContext, QgsExpressionContextUtils
from qgis.PyQt.QtWidgets import QApplication

from qltop.core.general_tools import *


class loadMesure:
    """
    Purpose :
        - Get a list of mesures from an Ltop.mes
    Input :
        - Ltop.mes /.me file
    Output :
        - List of station and measurements ready to import in the database
    """

    # Class variables
    station_column_separator = [2, 10, 4, 20, 6, 4, 6, 8, 18, 12]
    mesure_column_separator = [2, 10, 4, 20, 6, 4, 6, 6, 32]

    def __init__(self, mes_path):
        self.mes_path = mes_path
        self.mes_format = ["$$ME"]          ## Implemented Ltop.mes terrestrial only no GNSS
        self.file_content = self.read_mes_file(self.mes_path)
        self.file_list = self.split_mes_attributes(self.file_content)

    def read_mes_file(self, filename):
        """ Read the Ltop.mes file and create a list of the content """
        to_keep = ("$$ME", "ST", "RI", "ZD", "DS")  ## All other value are discarded (empty lines, commentary lines ...)
        try:
            with codecs.open(filename, "r", encoding="mbcs") as file:  ## mbcs = 'codecs' module 'ainsi' encoding equivalent
                lines = file.read().splitlines()                       ## read each lines
                lines = filter(lambda x: x.startswith(to_keep), lines)
            return list(lines)
        except:
            print("Mesure -> Failed to read the Ltop.mes file")

    @classmethod
    def split_mes_attributes(cls, data):
        """ Extract the attributes of each mesure to a list """
        try:
            total_list = []    ## Title list + station list + mesure list
            if data:
                title_list = []          ## $$ header + title
                station_id = []          ## List to count how many duplicates stations exists
                station_list = []        ## Final station list with all the attributes
                mesure_list_basic = []   ## Intermediaire mesure list with the station informations
                mesure_list = []         ## Final mesure list with all the attributes
                first_line = data[0]                       ## First line of the Ltop.mes file
                title_list.append(first_line[0:4])         ## $$ME
                title_list.append(first_line[4:].strip())  ## Commentary
                for line in data[1:]:  ## [1:] = everything except the $$ header
                    type = line[0:2]
                    # Extraction station data
                    if type == "ST":
                        st_attr_lst = gt_splitter_ltop_format(line, cls.station_column_separator)  ## Extract all attributes
                        st_number = st_attr_lst[1]               ## Extract the station number only
                        station_id.append(st_number)             ## Append the station number to the station_id list
                        count_nbr = station_id.count(st_number)  ## Counts the number of times the same station is measured
                        st_attr_lst.insert(2, count_nbr)         ## Add the number of times the same station is measured to the list
                        station_list.append(st_attr_lst)         ## Append the result to the station list
                    # Extraction measurement data
                    else:
                        mes_attr_lst = gt_splitter_ltop_format(line, cls.mesure_column_separator)
                        if station_id:
                            related_station = station_id[-1]               ## Stations name to which the points belong
                            count_nbr = station_id.count(related_station)  ## Counts the number of times the same station is measured
                            tmp_station_id = len(station_id)
                        else:  ## If a station title is missing -> keep the measurement
                            related_station = ""
                            count_nbr = ""
                            tmp_station_id = 0
                        mes_attr_lst.insert(0, tmp_station_id)   ## Add the station list index
                        mes_attr_lst.insert(2, related_station)  ## Add the station name
                        mes_attr_lst.insert(3, count_nbr)        ## Add the number of times the same station is measured to the list
                        mesure_list_basic.append(mes_attr_lst)
                list_mes_all_station = cls.sort_lst_attr(mesure_list_basic, 0)  ## 0 = station name
                for item in list_mes_all_station:
                    list_mes_by_station = cls.sort_lst_attr(item, 4)  ## 4 = point vise name
                    for item in list_mes_by_station:
                        canevas = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]  ## Canevas as defined in the mes_mesure table
                        for mes in item:
                            canevas[0] = mes[2]  ## Station name
                            canevas[1] = mes[3]  ## Station id = number of times the same station is measured
                            canevas[2] = mes[4]  ## Point vise name
                            canevas[3] = mes[5]  ## Point vise type
                            if mes[1] == "RI":   ## Direction
                                canevas[4] = mes[6]   ## Point vise valeur
                                canevas[7] = mes[7]   ## Point vise erreur moyenne
                                canevas[10] = mes[8]  ## Point vise groupe
                            if mes[1] == "ZD":  ## Angle zénithal
                                canevas[5] = mes[6]   ## Point vise valeur
                                canevas[8] = mes[7]   ## Point vise erreur moyenne
                                canevas[11] = mes[8]  ## Point vise groupe
                            if mes[1] == "DS":  ## Distance
                                canevas[6] = mes[6]   ## Point vise valeur
                                canevas[9] = mes[7]   ## Point vise erreur moyenne
                                canevas[12] = mes[8]  ## Point vise groupe
                            canevas[13] = mes[9]   ## Hi
                            canevas[14] = mes[10]  ## Hs
                            canevas[15] = mes[11]  ## Erreur centrage
                        mesure_list.append(canevas)
                # Add result to the return list
                total_list.append(title_list)
                total_list.append(station_list)
                total_list.append(mesure_list)
                return total_list
        except:
            iface.messageBar().pushMessage("Attention : ",
                                           u"*** Erreur à l'import des mesures, merci de contrôler les données ***",
                                           level=Qgis.Warning,
                                           duration=3)
            print("Mesure -> Failed to extract the observations attributes to a list (def split_mes_attributes)")

    @staticmethod
    def sort_lst_attr(data, attr_index):
        """ Create a list of list based on one attribute index """
        new_lst = []
        sort_lst = sorted(data, key=lambda x: x[attr_index])
        for k, v in groupby(sort_lst, key=lambda x: x[attr_index]):
            new_lst.append(list(v))
        return new_lst


class displayLayerMesure:
    """
        Display the measurement content of the database in the Qgis canvas
        Input : database name, table to query
        Output : Qgis layer
    """

    # Class variables
    layer_name = "qltop_mesure"
    qml_style_mesure = "style_qltop_mesure.qml"

    def __init__(self, list_mesures, selected_epsg):
        self.list_mesures = list_mesures
        self.selected_epsg = selected_epsg
        self.create_mesure_layer()

    def create_mesure_layer(self):
        """ Create an temporary point layer in the Qgis canvas """
        try:
            QApplication.setOverrideCursor(Qt.WaitCursor)  ## Start the 'wait' cursor
            if self.list_mesures:

                vl = QgsVectorLayer("Linestring?crs=" + self.selected_epsg, self.layer_name, "memory")
                pr = vl.dataProvider()

                # add fields
                pr.addAttributes([QgsField("station", QVariant.String),
                                  QgsField("st_num",  QVariant.Int),
                                  QgsField("st_y",  QVariant.Double, "double", 12, 4),
                                  QgsField("st_x", QVariant.Double, "double", 12, 4),
                                  QgsField("st_h",  QVariant.Double, "double", 10, 4),
                                  QgsField("st_hi",  QVariant.Double),
                                  QgsField("vise",  QVariant.String),
                                  QgsField("vise_y",  QVariant.Double, "double", 12, 4),
                                  QgsField("vise_x",  QVariant.Double, "double", 12, 4),
                                  QgsField("vise_h",  QVariant.Double, "double", 10, 4),
                                  QgsField("vise_hs",  QVariant.Double),
                                  QgsField("vise_category",  QVariant.Int),
                                  QgsField("dhz",  QVariant.Double),
                                  QgsField("dh",  QVariant.Double)])
                vl.updateFields()  # tell the vector layer to fetch changes from the provider

                # add features
                for item in self.list_mesures:
                    st_y = float(item[2])
                    st_x = float(item[3])
                    vise_y = float(item[7])
                    vise_x = float(item[8])
                    fet = QgsFeature()
                    fet.setGeometry(QgsGeometry.fromPolyline([QgsPoint(st_y, st_x),
                                                              QgsPoint(vise_y, vise_x)]))
                    fet.setAttributes(list(item))
                    pr.addFeatures([fet])

                # Calculate the "dhz" and "dh" columns
                expression1 = QgsExpression("round((sqrt((st_y - vise_y)^2 + (st_x - vise_x)^2)), 3)")
                expression2 = QgsExpression("round((vise_h + vise_hs - st_h - st_hi), 3)")
                context = QgsExpressionContext()
                context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(vl))

                vl.startEditing()
                for f in vl.getFeatures():
                    context.setFeature(f)
                    f["dhz"] = expression1.evaluate(context)
                    f["dh"] = expression2.evaluate(context)
                    vl.updateFeature(f)
                vl.commitChanges()

                # add preconfigured qgis.qml style file
                plugin_folder = os.path.dirname(os.path.dirname(__file__))
                qml_file = Path(plugin_folder) / "qml" / self.qml_style_mesure
                if qml_file.is_file():  # Test if file exist, avoid error if he is missing
                    vl.loadNamedStyle(str(qml_file))

                # update layer's extent when new features have been added
                vl.updateExtents()

                # zoom to the layer extent
                canvas = iface.mapCanvas()
                canvas.setExtent(vl.extent())

                # Show in project
                self.rmv_old_qgs_mesure_layer()
                QgsProject.instance().addMapLayer(vl)
        except:
            print("Mesures -> Failed to create a new measurements Qgis layer (def create_mesure_layer)")
            QApplication.restoreOverrideCursor()  ## Stop the 'wait' cursor
        finally:
            QApplication.restoreOverrideCursor()  ## Stop the 'wait' cursor

    @classmethod
    def rmv_old_qgs_mesure_layer(cls):
        """ Remove preexisting mesure layer """
        try:
            names = [layer.name() for layer in QgsProject.instance().mapLayers().values()]
            qgs_instance = QgsProject.instance()
            for name in names:
                if name == cls.layer_name:
                    qgs_instance.removeMapLayer(qgs_instance.mapLayersByName(name)[0].id())
        except:
            print("Mesures -> Failed to remove the preexisting measurements Qgis layer (def rmv_old_qgs_mesure_layer)")


class mesStationModel(QtSql.QSqlTableModel):
    """ Model used to define the 'stations' table in the '.MES' panel """

    def __init__(self, parent=None):
        QtSql.QSqlTableModel.__init__(self, parent=parent)
        self.setTable("mes_station")
        self.setEditStrategy(QtSql.QSqlTableModel.OnFieldChange)
        self.select()

    def data(self, index, role=Qt.DisplayRole):
        """ Define the role applied to each column """
        val = QtSql.QSqlTableModel.data(self, index, role)
        if role == Qt.TextAlignmentRole:
            if index.column() == 3 or index.column() == 6 or index.column() \
                    == 7 or index.column() == 8 or index.column() == 11:
                return Qt.AlignRight | Qt.AlignVCenter
            else:
                return Qt.AlignLeft | Qt.AlignVCenter
        if role == Qt.EditRole:
            if index.column() == 2:  # Nom de station
                if val:
                    if len(val) > 10:
                        return val[0:10]
                    else:
                        return val
        if role == Qt.DisplayRole or role == Qt.EditRole:
            # EM Général
            if index.column() == 6:
                try:
                    if gt_isfloat(val):
                        return "{:.1f}".format(round(float(val), 1))
                except ValueError:
                    pass
            if index.column() == 8:
                try:
                    if gt_isfloat(val):
                        return "{:.4f}".format(round(float(val), 4))
                except ValueError:
                    pass
        return val


class mesMesureModel(QtSql.QSqlTableModel):
    """ Model used to define the 'mesure' table in the '.MES' panel """

    def __init__(self, parent=None):
        QtSql.QSqlTableModel.__init__(self, parent=parent)
        self.setTable("mes_mesure")
        self.setEditStrategy(QtSql.QSqlTableModel.OnFieldChange)
        self.select()

    def data(self, index, role=Qt.DisplayRole):
        """ Define the role applied to each column """
        val = QtSql.QSqlTableModel.data(self, index, role)
        if role == Qt.TextAlignmentRole:
            if index.column() == 1 or index.column() == 3 or index.column() == 4:
                return Qt.AlignLeft | Qt.AlignVCenter
            else:
                return Qt.AlignRight | Qt.AlignVCenter
        if role == Qt.DisplayRole or role == Qt.EditRole:
            # Direction, angle zénithal, distance
            if index.column() == 5 or index.column() == 6 or index.column() == 7:
                try:
                    if gt_isfloat(val):
                        return "{:.5f}".format(round(float(val), 5))
                except ValueError:
                    pass
            # EM Direction, EM angle zénithal, EM distance
            if index.column() == 8 or index.column() == 9 or index.column() == 10:
                try:
                    if gt_isfloat(val):
                        return "{:.3f}".format(round(float(val), 3))
                except ValueError:
                    pass
            # Hauteur de signal
            if index.column() == 15:
                try:
                    if gt_isfloat(val):
                        return "{:.4f}".format(round(float(val), 4))
                except ValueError:
                    pass
        return val


class mesUpdateFile():
    """
    Update the Ltop.mes selected file with the database content
    """
    def __init__(self, table_stations, table_mesures, selected_mes_file):
        self.table_stations = table_stations
        self.table_mesures = table_mesures
        self.mes_file = selected_mes_file
        self.list_print = self.extract_data()
        self.write_mes_file(self.mes_file, self.list_print)

    @staticmethod
    def round_double_attr_station(data):
        """
        Remove the unwanted attributes (id , pfp and pfa), then
        round the 'double' attributes and convert to string
        """
        rmv_attr = [0, 2, 11, 12, 13]  ## remove id_station, num_station, coordY, coordX, altitudeH
        round_1 = [3, 8]               ## em, ec
        round_4 = [5]                  ## Hi
        try:
            # Remove unwanted attributes
            station = [i for j, i in enumerate(data) if j not in rmv_attr]
            # Convert float to to string vith rounded decimal
            for idx in enumerate(station):
                if idx[1] is None:
                    station[idx[0]] = ""
                if idx[0] in round_1 and idx[1]:
                    station[idx[0]] = "{:.1f}".format(float(idx[1]))
                if idx[0] in round_4 and idx[1]:
                    station[idx[0]] = "{:.4f}".format(float(idx[1]))
            station.insert(0, "ST")  ## Add Ka value
            return station
        except:
            print("Mesure -> Failed to round the stations attributes (def round_double_attr_station)")

    @staticmethod
    def round_double_attr_mesure(data):
        """
        Remove the unwanted attributes (id_station, coordY, coordX, altitudeH, mesure_category), then
        round the 'double' attributes and convert to string
        """
        rmv_attr = [0, 15, 16, 17, 18]  ## Remove id_station, num_station, coordY, coordX, altitudeH
        round_1 = [13]                  ## ec
        round_3 = [5, 6, 7]             ## em_ri, em_zd, em_ds
        round_4 = [11, 12]              ## Hi, Hs
        round_5 = [2, 3, 4]             ## Ri, Zd, Ds
        try:
            # Remove unwanted attributes
            mesure = [i for j, i in enumerate(data) if j not in rmv_attr]
            # Convert float to to string vith rounded decimal
            for idx in enumerate(mesure):
                if idx[1] is None:
                    mesure[idx[0]] = ""
                if idx[0] in round_1 and idx[1]:
                    mesure[idx[0]] = "{:.1f}".format(float(idx[1]))
                if idx[0] in round_3 and idx[1]:
                    mesure[idx[0]] = "{:.3f}".format(float(idx[1]))
                if idx[0] in round_4 and idx[1]:
                    mesure[idx[0]] = "{:.4f}".format(float(idx[1]))
                if idx[0] in round_5 and idx[1]:
                    mesure[idx[0]] = "{:.5f}".format(float(idx[1]))
            return mesure
        except:
            print("Mesure -> Failed to round the measurements attributes (def round_double_attr_mesure)")

    def unsplit_attr_station(self, data):
        """ Concatenate the station attributes in a single line as described in the Ltop.mes schema model """
        column_separator = [2, 10, 4, 12, 6, 4, 6, 8, 18, 6]  ## length of each attributes
        right_alignment = [4, 5, 6, 9]  ## This idx must have a right alignment (float) | other left (string)
        join_data = []  ## Return list
        try:
            for idx in enumerate(data):
                max_length = column_separator[idx[0]]
                actual_length = len(str(idx[1]))
                if actual_length > max_length:
                    data[idx[0]] = str(idx[1][-max_length:])
                if actual_length < max_length:
                    if idx[0] in right_alignment:  ## float value only
                        data[idx[0]] = " "*(max_length-actual_length) + str(idx[1])
                    else:  ## string value only
                        data[idx[0]] = str(idx[1]) + " "*(max_length-actual_length)
            data.insert(9, " "*6)  ## Add empty space between operator and ec !
            data.insert(3, " "*8)  ## Add empty space between type and meteo !
            join_data.append("".join(map(str, data)))
            return join_data
        except:
            print("Mesure -> Failed to transform the station data to Ltop rows (def unsplit_attr_station)")

    def unsplit_attr_mesure(self, data):
        """ Concatenate the mesure attributes in a single line as described in the Ltop.mes schema model """
        column_separator = [2, 10, 4, 12, 6, 4, 6, 6, 6]  ## length of each attributes
        right_alignment = [3, 4, 5, 6, 7, 8]  ## This idx must have a right alignment (float) | other left (string)
        join_data = []  ## Return list
        try:
            for idx in enumerate(data):
                max_length = column_separator[idx[0]]
                actual_length = len(str(idx[1]))
                if actual_length > max_length:
                    data[idx[0]] = str(idx[1][-max_length:])
                if actual_length < max_length:
                    if idx[0] in right_alignment:  ## float value only
                        data[idx[0]] = " "*(max_length-actual_length) + str(idx[1])
                    else:  ## string value only
                        data[idx[0]] = str(idx[1]) + " "*(max_length-actual_length)
            data.insert(8, " "*26)  ## Add empty space between operator and ec !
            data.insert(3, " "*8)   ## Add empty space between type and valeur mesurée !
            join_data.append("".join(map(str, data)))
            return join_data
        except:
            print("Mesure -> Failed to transform the measurements data to Ltop rows (def unsplit_attr_mesure)")

    def extract_data(self):
        """ Extract the station and the measurement data """
        list_all_station = [el[0] for el in self.table_mesures]      ## Extract station from the measurement rows
        list_unique_station = list(dict.fromkeys(list_all_station))  ## Eliminate the duplicates in the previous list
        list_print = []  ## Final list to print in the Ltop.mes file
        rmv_attr_ri = [3, 4, 6, 7, 9, 10]  ## Remove attributes to have only an 'direction' list
        rmv_attr_zd = [2, 4, 5, 7, 8, 10]  ## Remove attributes to have only an 'angle zénithal' list
        rmv_attr_ds = [2, 3, 5, 6, 8, 9]   ## Remove attributes to have only an 'distance' list
        try:
            # Extract station data
            for station in self.table_stations:
                if station[0] in list_unique_station:
                    clean_list = self.round_double_attr_station(station)
                    final_list = self.unsplit_attr_station(clean_list)
                    list_print.append(final_list[0])
                    # Extract measurement by station
                    list_ri = []  ## List 'direction' measurement for the current station
                    list_zd = []  ## List 'angle zénithal' measurement for the current station
                    list_ds = []  ## List 'distance' measurement for the current station
                    for elem in self.table_mesures:
                        if elem[0] == station[0]:
                            clean_list = (self.round_double_attr_mesure(elem))
                            if clean_list[2]:  ## Direction
                                mesure_ri = [i for j, i in enumerate(clean_list) if j not in rmv_attr_ri]
                                mesure_ri.insert(0, "RI")  ## Add Ka value
                                mesure_ri = self.unsplit_attr_mesure(mesure_ri)
                                list_ri.append(mesure_ri[0])
                            if clean_list[3]:  ## Angle zénithal
                                mesure_zd = [i for j, i in enumerate(clean_list) if j not in rmv_attr_zd]
                                mesure_zd.insert(0, "ZD")  ## Add Ka value
                                mesure_zd = self.unsplit_attr_mesure(mesure_zd)
                                list_zd.append(mesure_zd[0])
                            if clean_list[4]:  ## Distance
                                mesure_ds = [i for j, i in enumerate(clean_list) if j not in rmv_attr_ds]
                                mesure_ds.insert(0, "DS")  ## Add Ka value
                                mesure_ds = self.unsplit_attr_mesure(mesure_ds)
                                list_ds.append(mesure_ds[0])
                    for elem in list_ri:
                        list_print.append(elem)
                    for elem in list_zd:
                        list_print.append(elem)
                    for elem in list_ds:
                        list_print.append(elem)
            return list_print
        except:
            print("Mesure -> Failed to extract the stations and measurements data from the database (def extract_data)")

    @staticmethod
    def write_mes_file(filename, point_data):
        """
        Read the Ltop.koo file, retrieve the first line
        then replace the measurement content
        """
        try:
            with codecs.open(filename, "r+", encoding="mbcs") as file:    ## mbcs = 'codecs' module 'ainsi' encoding equivalent
                items = list(map(lambda x: x + "\r\n", point_data))  ## Add break line at the end of each line
                first_line = file.readline()
                if first_line[:2] == "$$":
                    items.insert(0, first_line)
                file.seek(0)
                file.writelines(items)
                file.truncate()
            iface.messageBar().pushMessage("Info : ",
                                           u"*** Mise jour du fichier '{}' effectué avec succès ***".format(filename),
                                           level=Qgis.Success,
                                           duration=2)
        except:
            iface.messageBar().pushMessage("Attention : ",
                                           u"*** La mise jour du fichier '{}' a échoué ***".format(filename),
                                           level=Qgis.Warning,
                                           duration=3)
            print("Mesure -> Failed to write the measurements to the selected Ltop.mes file (def write_mes_file)")
