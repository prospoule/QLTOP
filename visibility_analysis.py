# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QLtop
                                 A QGIS plugin
 Outil interactif de préanalyse pour le logiciel LTOP
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-09-25
        git sha              : $Format:%H$
        copyright            : (C) 2020 by HEIG-VD | Nicolas Szakacs
        email                : nicolas.szakacs@heig-vd.ch
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; Version 3 of the License.               *
 *                                                                         *
 ***************************************************************************/
"""

import os
import math
from pathlib import Path

from qltop.core.database import *

# Used to create a Qgis temporary layer
from qgis.utils import iface
from qgis.PyQt.QtCore import QVariant
from qgis.core import QgsVectorLayer, QgsField, QgsFeature, QgsGeometry, QgsPointXY, \
                      QgsProject, QgsExpression, QgsExpressionContext, QgsExpressionContextUtils

# Qgis processing tools
import processing


class visibilityAnalysis:
    """
    Purpose :
         - Determine if a measurement is possible
           from A to B through the topography
    Input :
        - MNS/MNT raster file
        - Elevation band number
        - Security distance -> default = 0
        - Discretization distance -> default = 10
        - Measurements defined in the .MES pannel or at least in the db.qltop
    Output :
        - Qgis point layer with visualization of
          the possible/impossible view sight
    """

    # Class variables
    layer_name = "qltop_visibility_point"
    qml_style_point = "style_qltop_visibility_point.qml"

    def __init__(self, db_name, epsg, raster_layer, band_number,
                 secur_dist, discr_dist):
        self.db_name = db_name
        self.epsg = epsg
        self.raster_layer = raster_layer
        self.band_number = str(band_number)
        self.secur_dist = 0 if not secur_dist else float(secur_dist)   ## Default value if empty
        self.discr_dist = 10 if not discr_dist else float(discr_dist)  ## Default value if empty
        self.mesure = generalToolsDB.select_tbl_items(self.db_name, "station_mesure_view")
        self.lst_new_point = self.discretiz_new_point(self.mesure)
        self.temp_visib_layer = self.create_point_layer()
        self.copy_raster_value()

    def create_point_layer(self):
        """ Create an temporary point layer in the Qgis canvas """
        try:
            if self.lst_new_point:

                # create an empty layer
                vl = QgsVectorLayer("Point?crs=" + self.epsg, "temp_" + self.layer_name, "memory")
                pr = vl.dataProvider()

                # add fields
                pr.addAttributes([QgsField("Station", QVariant.String),
                                  QgsField("St_H",  QVariant.Double),
                                  QgsField("St_Hi",  QVariant.Double),
                                  QgsField("Point_vise",  QVariant.String),
                                  QgsField("Pnt_H",  QVariant.Double),
                                  QgsField("Pnt_Hs",  QVariant.Double),
                                  QgsField("H_doit",  QVariant.Double),
                                  QgsField("H_avoir",  QVariant.Double),
                                  QgsField("Delta",  QVariant.Double)])
                vl.updateFields()  # tell the vector layer to fetch changes from the provider

                # add features
                for item in self.lst_new_point:
                    pos_y = item[12]
                    pos_x = item[13]
                    fet = QgsFeature()
                    fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(pos_y,pos_x)))
                    fet.setAttributes([item[0], item[4], item[5], item[6], item[9], item[10], item[14]])
                    pr.addFeatures([fet])

                # update layer's extent when new features have been added
                vl.updateExtents()

                return vl
        except:
            print("Visibility calculation -> Failed to create the qltop_visibility_point layer")

    def discretiz_new_point(self, mesure):
        """ Discretization of the vector """
        if mesure:
            try:
                discretiz_point = []
                for item in mesure:
                    dhz = self.distance(item)
                    if dhz > self.discr_dist:
                        dy = float(item[7]) - float(item[2])    ## delta y
                        dx = float(item[8]) - float(item[3])    ## delta x
                        dz = self.diff_alt(item)  ## delta z
                        accr_y = dy / dhz  ## increase the y coordinate
                        accr_x = dx / dhz  ## increase the x coordinate
                        accr_z = dz / dhz  ## increase the z coordinate
                        count = math.floor(dhz/self.discr_dist)  ## number of point to create
                        for nbr in range(1, count + 1):
                            new_point = list(item)
                            new_y = accr_y * nbr * self.discr_dist + float(item[2])
                            new_x = accr_x * nbr * self.discr_dist + float(item[3])
                            new_z = accr_z * nbr * self.discr_dist + float(item[4]) + float(item[5])
                            new_point.append(round(new_y, 3))
                            new_point.append(round(new_x, 3))
                            new_point.append(round(new_z, 3))
                            discretiz_point.append(new_point)
                return discretiz_point
            except:
                print("Visibility calculation -> Failed to discretize the measurements vectors")
        else:
            iface.messageBar().pushMessage("Attention : ",
                                           u"*** Aucune mesures dans la base de données, calcul impossible ***",
                                           level=Qgis.Warning,
                                           duration=3)

    @staticmethod
    def diff_alt(vector):
        """
        Calculate the delta H between
        the start and finish of the vector
        """
        St_H = float(vector[4])
        St_Hi = float(vector[5])
        Pnt_H = float(vector[9])
        Pnt_Hs = float(vector[10])
        delta_h = (Pnt_H + Pnt_Hs) - (St_H + St_Hi)
        return delta_h

    @staticmethod
    def distance(vector):
        """
        Calculate the horizontal distance between
        the start and finish of the vector
        """
        start_y = float(vector[2])
        start_x = float(vector[3])
        end_y = float(vector[7])
        end_x = float(vector[8])
        distance = math.sqrt((start_y - end_y)**2 + (start_x - end_x)**2)
        return distance

    @classmethod
    def rmv_old_qgs_point_layer(cls):
        """ Remove preexisting point layer """
        try:
            names = [layer.name() for layer in QgsProject.instance().mapLayers().values()]
            qgs_instance = QgsProject.instance()
            for name in names:
                if name == cls.layer_name:
                    qgs_instance.removeMapLayer(qgs_instance.mapLayersByName(name)[0].id())
        except:
            print("Visibility calculation -> Failed to remove the old qltop_visibility_point layer")

    def copy_raster_value(self):
        """
        Add the raster elevation values to the input layer points.
        Output : copy of the input layer with the new calculate elevation attribut.
        """
        try:
            column_prefix = "qltop_rvalue"

            # Remove existing layer
            self.rmv_old_qgs_point_layer()

            # Qgis processing "Sample raster values"
            process_parameters = {"INPUT": self.temp_visib_layer, "RASTERCOPY": self.raster_layer, "COLUMN_PREFIX": "", "OUTPUT": ""}
            process_parameters["COLUMN_PREFIX"] = column_prefix
            process_parameters["OUTPUT"] = "memory:{}".format(self.layer_name)
            result_layer = processing.run("qgis:rastersampling", process_parameters)
            output_layer = result_layer["OUTPUT"]

            # add preconfigured qgis.qml style file
            plugin_folder = os.path.dirname(os.path.dirname(__file__))
            qml_file = Path(plugin_folder) / "qml" / self.qml_style_point
            if qml_file.is_file():  # Test if file exist, avoid error if he is missing
                output_layer.loadNamedStyle(str(qml_file))

            # Calculate the height difference between the raster height value and the coordinates
            self.calc_height_difference(output_layer, column_prefix, self.band_number, self.secur_dist)

            # Remove imported raster band fields
            self.rmv_unwanted_raster_fields(output_layer, column_prefix)

            # Add layer to the Qgis canevas
            QgsProject.instance().addMapLayer(output_layer)

        except:
            print("Visibility calculation -> Failed to add the raster elevation values to the input layer points")

    @staticmethod
    def calc_height_difference(layer, column_prefix, band_number, secur_dist):
        """
        Calculate the height difference between the raster height value and the coordinates
        Add the result to the 'Delta' field
        """
        try:
            context = QgsExpressionContext()
            context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))

            # Qgis V3.14 -> V3.16 remove the "_" between the name and the band number
            field_names = [field.name() for field in layer.fields()]  ## List of the layer fields
            if column_prefix + "_" + band_number in field_names:
                prep_expr_1 = "round({}, 3)".format(column_prefix + "_" + band_number)
            else:
                prep_expr_1 = "round({}, 3)".format(column_prefix + band_number)

            expression1 = QgsExpression(prep_expr_1)
            layer.startEditing()
            for feat in layer.getFeatures():
                context.setFeature(feat)
                feat["H_avoir"] = expression1.evaluate(context)
                layer.updateFeature(feat)
            layer.commitChanges()

            prep_expr_2 = "round((H_doit - H_avoir - {}), 3)".format(secur_dist)
            expression2 = QgsExpression(prep_expr_2)
            layer.startEditing()
            for feat in layer.getFeatures():
                context.setFeature(feat)
                feat["Delta"] = expression2.evaluate(context)
                layer.updateFeature(feat)
            layer.commitChanges()
        except:
            print("Visibility calculation -> Failed to calculate the height difference between the raster height value and the coordinates")

    @staticmethod
    def rmv_unwanted_raster_fields(layer, COLUMN_PREFIX):
        """ Remove imported raster band fields """
        try:
            # Extract index column to remove
            idx_remove = []  ## index of fields to remove
            for idx, field in enumerate(layer.fields()):
                if field.name()[0:12] == COLUMN_PREFIX:
                    idx_remove.append(idx)
            # Remove the column by the last
            pr = layer.dataProvider()
            idx_remove.reverse()  ## Reverse to remove column by the end to avoid error
            for idx in idx_remove:
                pr.deleteAttributes([idx])
            layer.updateFields()
        except:
            print("Visibility calculation -> Failed to remove the fields from the input raster")
